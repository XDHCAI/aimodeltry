import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from tqdm import tqdm
import pandas as pd
import io
from PIL import Image, ImageOps
from torchvision.datasets import MNIST
import matplotlib.pyplot as plt
import os
os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE"




transform=transforms.Compose([
    transforms.Resize((28,28)),
    transforms.ToTensor(),
    transforms.Normalize((0.5,),(0.5,))
])

train_dataset = MNIST(root='./data', train=True, download=True, transform=transform)
test_dataset = MNIST(root='./data', train=False, download=True, transform=transform)


class datasets():
    def __init__(self,path,transform=None):
        self.data = pd.read_parquet(path)
        self.transform = transform

    def __len__(self):
        return len(self.data)

    def __getitem__(self, index):
        image =self.data.iloc[index]["image"]["bytes"]
        label = self.data.iloc[index]["label"]

        image = Image.open(io.BytesIO(image)).convert('L')
        if self.transform:
            image = self.transform(image)
        return image, label

train_path = "E:\训练集\train-images-idx3-ubyte\train-images.idx3-ubyte "
test_path = "E:\测试集\t10k-images-idx3-ubyte\t10k-images.idx3-ubyte"
##train_dataset = datasets(train_path,transform = transform)
##test_dataset = datasets(test_path,transform = transform)
train_dataloader = torch.utils.data.DataLoader(dataset=train_dataset,batch_size=64,shuffle=True)
test_dataloader = torch.utils.data.DataLoader(dataset=test_dataset,batch_size=64,shuffle=False)

class FCNN(nn.Module):
    def __init__(self,channel=1, mid_channel=32,final_chanel=64):
        super(FCNN,self).__init__()
        self.channel = channel
        self.mid_channel = mid_channel
        self.final_chanel = final_chanel
        self.layer1 = nn.Sequential(
            nn.Conv2d(self.channel,self.mid_channel,kernel_size=(3,3),padding=1),
            nn.BatchNorm2d(self.mid_channel),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=(2,2)),
        )
        self.layer2 = nn.Sequential(
            nn.Conv2d(self.mid_channel,self.final_chanel,kernel_size=(3,3),padding=1),
            nn.BatchNorm2d(self.final_chanel),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=(2,2)),
        )
        self.dropout = nn.Dropout(p=0.2)
        self.fc1= nn.Linear(7*7*self.final_chanel,512)
        self.fc2= nn.Linear(512, 128)
        self.fc3= nn.Linear(128, 10)

    def forward(self,x):
        out = self.layer1(x)
        out = self.layer2(out)
        out =out.view(out.size(0),-1)
        out = self.fc1(out)
        out = self.dropout(out)
        out = self.fc2(out)
        out = self.fc3(out)
        return out

model = FCNN()
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.001)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
num_epochs =  10


for epoch in range(num_epochs):
    model.train()
    total_loss = 0
    for images, labels in tqdm(train_dataloader,desc=f"Epoch {epoch+1}"):
        image, labels =images.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(image)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

 #   print(f"Epoch {epoch+1} loss: {total_loss/len(train_dataloader)}")

png_image=Image.open("C:\\Users\\zheng hao shuai\Pictures\Screenshots\屏幕截图 2025-03-12 215438.png")
jpg_image=png_image.convert('RGB')
jpg_image.save("output.jpg")
model.eval()
correct = 0
total = 0
image_path="output.jpg"
image=Image.open(image_path).convert('L')
image=ImageOps.invert(image)
image=transform(image)
image=image.unsqueeze(0)
image_vis = image.squeeze().cpu().numpy()
plt.imshow(image_vis, cmap='gray')
plt.title("预处理后的图片")
plt.show()

#with torch.no_grad():
#    for images, labels in test_dataloader:
#        images, labels = images.to(device), labels.to(device)
#        outputs = model(images)
#        _, predicted = torch.max(outputs.data, 1)

#        total+= labels.size(0)
 #       correct += (predicted == labels).sum().item()
  #  print(f"Accuracy of the network on the 10000 test images: {100*correct/total}")
with torch.no_grad():
    outputs=model(image.to(device))
    predicted_class = outputs.argmax(dim=1)
    print(predicted_class.item())
